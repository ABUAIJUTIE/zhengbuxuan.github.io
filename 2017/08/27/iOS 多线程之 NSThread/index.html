<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS 多线程 NSThread Swift 3 · Hexo</title><meta name="description" content="iOS 多线程 NSThread Swift 3 - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://zhengbuxuan.github.io/atom.xml" title="Hexo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/zhengbuxuan" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/zhengbuxuan" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS 多线程 NSThread Swift 3</h1><div class="post-info">Aug 27, 2017</div><div class="post-content"><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>NSThread 是 iOS 多线程当中最基础最轻量的多线程技术，但是需要自行管理线程的生命周期和同步问题，所以使用起来其实比较麻烦。<br>在 Swift 3 中，<strong>NSThread</strong> 已经被重命名为 <strong>Thread</strong>，很多的方法名也进行了修改。<br>下面就写一下自己学到的东西，当作学习笔记，以后可以翻看。如果有错误的地方望指正。</p>
<h2 id="1-创建线程和获取线程"><a href="#1-创建线程和获取线程" class="headerlink" title="1. 创建线程和获取线程"></a>1. 创建线程和获取线程</h2><ul>
<li>直接创建线程是最基本的创建方式，<strong>可以获取到线程线程对象</strong>，适合需要对线程对象进行操作的情况。需要<strong>手动启动</strong>。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//直接创建</span></div><div class="line"><span class="keyword">let</span> thread = <span class="type">Thread</span>.<span class="keyword">init</span>(target: <span class="keyword">self</span>, selector: <span class="type">Selector</span>(<span class="string">"run"</span>), object: <span class="literal">nil</span>)</div><div class="line">thread.name = <span class="string">"firstThread"</span></div><div class="line">thread.start()</div></pre></td></tr></table></figure>
<ul>
<li>分离子线程，<strong>不能获取到线程对象</strong>，创建之后<strong>自启动</strong>。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//分离子线程</span></div><div class="line"><span class="type">Thread</span>.detachNewThreadSelector(<span class="type">Selector</span>(<span class="string">"run"</span>), toTarget: <span class="keyword">self</span>, with: <span class="literal">nil</span>)</div></pre></td></tr></table></figure>
<ul>
<li>开启一条后台线程，同样<strong>不能获取到线程对象</strong>，创建后<strong>自启动</strong>。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//后台线程</span></div><div class="line"><span class="keyword">self</span>.performSelector(inBackground: <span class="type">Selector</span>(<span class="string">"run"</span>), with: <span class="literal">nil</span>)</div></pre></td></tr></table></figure>
<ul>
<li>自定义线程类继承自Thread，对内部的方法进行重写封装，满足自定义需求。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//自定义线程</span></div><div class="line"><span class="keyword">let</span> customThread = <span class="type">CustomThread</span>()</div><div class="line">customThread.start()</div></pre></td></tr></table></figure>
<ul>
<li>获取线程</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取主线程</span></div><div class="line"><span class="keyword">let</span> mainThread = <span class="type">Thread</span>.main</div><div class="line"></div><div class="line"><span class="comment">//获取当前线程</span></div><div class="line"><span class="keyword">let</span> currentThread = <span class="type">Thread</span>.current</div><div class="line"></div><div class="line"><span class="comment">//判断当前线程是否为主线程 返回类型为Bool</span></div><div class="line"><span class="keyword">let</span> currentIsMain = <span class="type">Thread</span>.isMainThread</div></pre></td></tr></table></figure>
<h2 id="2-线程状态"><a href="#2-线程状态" class="headerlink" title="2. 线程状态"></a>2. 线程状态</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//退出线程</span></div><div class="line"><span class="type">Thread</span>.exit()</div><div class="line"></div><div class="line"><span class="comment">//线程休眠给定时间</span></div><div class="line"><span class="type">Thread</span>.sleep(forTimeInterval: <span class="number">1.0</span>)</div><div class="line"></div><div class="line"><span class="comment">//线程休眠至特定时间</span></div><div class="line"><span class="type">Thread</span>.sleep(until: <span class="type">Date</span>(timeIntervalSinceNow: <span class="number">1.0</span>))</div></pre></td></tr></table></figure>
<h2 id="3-线程同步与加锁"><a href="#3-线程同步与加锁" class="headerlink" title="3. 线程同步与加锁"></a>3. 线程同步与加锁</h2><p>关于同步和加锁，是多线程逃不掉的话题。Thread 中的线程同步一般用 NSCondition 来加锁实现。NSCondition(这个没有改名字…)主要使用的是 lock()、wait() 和 unlock()。<br>苹果的 API 文档是这么描述 NSCondition 的：</p>
<blockquote>
<p>The NSCondition class implements a condition variable whose semantics follow those used for POSIX-style conditions.<br>A condition object acts as both a lock and a checkpoint in a given thread.</p>
</blockquote>
<p>意思就是 NSCondition 所描述的条件对象在线程当中同时扮演锁(lock)和检查点(checkpoint)的角色。</p>
<blockquote>
<p>The lock protects your code while it tests the condition and performs the task triggered by the condition.<br>The checkpoint behavior requires that the condition be true before the thread proceeds with its task.<br>While the condition is not true, the thread blocks. It remains blocked until another thread signals the condition object.</p>
</blockquote>
<p>Lock 保护着你…… 的代码，以保证它们能按照逻辑来运行和满足条件时的触发执行。<br>线程要干活的时候需要 checkpoint 的条件为真，不然就阻塞罢工，直到其它线程给它发信号唤醒它。</p>
<p>下面是一个 🌰<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span> : <span class="title">UIViewController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//声明两个线程</span></div><div class="line">    <span class="keyword">var</span> thread_1: <span class="type">Thread</span>?</div><div class="line">    <span class="keyword">var</span> thread_2: <span class="type">Thread</span>?</div><div class="line"></div><div class="line">    <span class="comment">//创建两个 NSCondition</span></div><div class="line">    <span class="keyword">let</span> condition_1 = <span class="type">NSCondition</span>()</div><div class="line">    <span class="keyword">let</span> condition_2 = <span class="type">NSCondition</span>()</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        <span class="comment">//两个线程的创建和 thread_1 的启动</span></div><div class="line">        thread_1 = <span class="type">Thread</span>(target: <span class="keyword">self</span>, selector: #selector(<span class="keyword">self</span>.forThreadOne) , object: <span class="literal">nil</span>)</div><div class="line">        thread_2 = <span class="type">Thread</span>(target: <span class="keyword">self</span>, selector: #selector(<span class="keyword">self</span>.forThreadTwo), object: <span class="literal">nil</span>)</div><div class="line">        thread_1?.start()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//thread_1 需要执行的方法</span></div><div class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">forThreadOne</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">7</span> &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"Thread_1 is running for the #<span class="subst">\(i)</span> time(s)."</span>)</div><div class="line">            <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span> &#123;</div><div class="line">                <span class="comment">//判断 thread_2 是否在运行中，没运行就启动，如果在运行就发信号唤醒 thread_2</span></div><div class="line">                <span class="keyword">if</span> thread_2!.isExecuting &#123;</div><div class="line">                    condition_2.signal()</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    thread_2?.start()</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//锁住 thread_1</span></div><div class="line">                condition_1.lock()</div><div class="line">                condition_1.wait()</div><div class="line">                condition_1.unlock()</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Thread_1 says it is ended."</span>)</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//thread_2 需要执行的方法</span></div><div class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">forThreadTwo</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">7</span> &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"Thread_2 is running for the #<span class="subst">\(i)</span> time(s)."</span>)</div><div class="line">            <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span> &#123;</div><div class="line">                <span class="comment">//发信号唤醒 thread_1</span></div><div class="line">                condition_1.signal()</div><div class="line">                <span class="comment">//锁住 thread_2</span></div><div class="line">                condition_2.lock()</div><div class="line">                condition_2.wait()</div><div class="line">                condition_2.unlock()</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Thread_2 says it is over."</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Swift 还可以使用 objc_sync_enter(obj: Any!) 和 objc_sync_exit(obj: Any!) 来加互斥锁，二者必须成对使用，把需要加锁的代码放在它们两个中间。<br>比如举一个买 7 本书的 🌰<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> amountOfBooks = <span class="number">7</span></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</div><div class="line">        objc_sync_enter(<span class="keyword">self</span>)</div><div class="line">        <span class="keyword">let</span> current = amountOfBooks</div><div class="line">        <span class="keyword">if</span> current &gt; <span class="number">0</span> &#123;</div><div class="line">            amountOfBooks = current - <span class="number">1</span></div><div class="line">            <span class="built_in">print</span>(...)</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">print</span>(...)</div><div class="line">            <span class="keyword">break</span></div><div class="line">        &#125;</div><div class="line">        objc_sync_exit(<span class="keyword">self</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>题外话</strong><br>Swift 需要成对使用的方法很多，多到可以写一个总结…… 先挖个坑</p>
</blockquote>
<h2 id="4-线程通信"><a href="#4-线程通信" class="headerlink" title="4. 线程通信"></a>4. 线程通信</h2><p>主要涉及到的方法有三个，当前线程的、主线程的、指定线程的。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//当前线程</span></div><div class="line"><span class="keyword">self</span>.perform(#selector(<span class="keyword">self</span>.run), with: <span class="literal">nil</span>)</div><div class="line"></div><div class="line"><span class="comment">//主线程</span></div><div class="line"><span class="keyword">self</span>.performSelector(onMainThread: #selector(<span class="keyword">self</span>.run), with: <span class="literal">nil</span>, waitUntilDone: <span class="literal">true</span>)</div><div class="line"></div><div class="line"><span class="comment">//指定线程</span></div><div class="line"><span class="keyword">self</span>.perform(#selector(<span class="keyword">self</span>.run), on: anotherThread, with: <span class="literal">nil</span>, waitUntilDone: <span class="literal">true</span>)</div></pre></td></tr></table></figure></p>
<p>举一个非常简单的小 🌰，在某个 ViewController的viewDidLoad 里，开启了一个子线程，运行 createNumber() 方法，声明 number 并赋值 7。<br>完了以后，使用 performSelector(onMainThread:…) 切换到主线程，并且跑起 printNumber() 方法，把 number 作为参数传入。<br>完成简单的线程间通信传值。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span> : <span class="title">UIViewController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        <span class="type">Thread</span>.detachNewThreadSelector(#selector(<span class="keyword">self</span>.createNumber), toTarget: <span class="keyword">self</span>, with: <span class="literal">nil</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">createNumber</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">let</span> number = <span class="number">7</span></div><div class="line">        <span class="built_in">print</span>(<span class="string">"Current Thread: <span class="subst">\(Thread.current)</span>"</span>)</div><div class="line">        <span class="keyword">self</span>.performSelector(onMainThread: #selector(<span class="keyword">self</span>.printNumber(number:)), with: number, waitUntilDone: <span class="literal">true</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">printNumber</span><span class="params">(number: Int)</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"The number is: <span class="subst">\(number)</span>."</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>题外话 x 2</strong><br>#selector(@objc method) 是非常不 Swift 3 的写法，要求传入的是一个 @objc 的方法。<br>使用 Selector(“methodWithoutParameter”) 或者 Selector(“methodWithParameter:”) 的话就不用在方法前加 @objc 标签，但是会爆黄……</p>
</blockquote>
</div></article></div></main><footer><div class="paginator"><a href="/2017/08/27/hello-world/" class="prev">PREV</a><a href="/2017/08/27/iOS 多线程之 NSOperation/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="https://zhengbuxuan.github.io">John Doe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>